
<?php
echo "<p> OOП PHP! </p>" ;

/*                      ОБЪЕКТНО-ОРИЕНТИРОВАННОЕ ПРОГРАММИРОВАНИЕ!

 В объектно-ориентированном программировании основными элементами программы являются объекты (object). 
Они являются представлением реальных объектов, которые задействованы при решении реальной проблемы. 
Например, если приложение относится к предметной области продажи подержанных автомобилей, то, возможно, 
в качестве объектов будут выбраны автомобили и покупатели. Если же решаемая задача связана с космосом, 
то объекты будут представлять звезды и планеты. 
 
                       ОБЪЕКТЫ И КЛАССЫ! (-> свойства и методы)
                                ___Объекты___:
Основными элементами объектно-ориентированных программ являются объекты (object).
Лучше всего их представлять как физические объекты из реального мира.
Например, автомобиль является объектом с набором свойств (или атрибутов), таких как цвет, название модели,
двигатель и тип шин. Кроме того, автомобиль может также выполнять некоторые действия,
например перемещаться вперед и назад, парковаться, поворачивать и останавливаться. 
В общем случае объекты соответствуют именам существительным. 
Однако объекты — это не просто физические объекты. Как и имена существительные, 
зачастую объекты являются более концептуальными. Например, банковский счет,  компьютерная учетная запись, 
залог, файл, база данных, заказы, сообщения, электронная почта, адреса, песни, 
телевизионные шоу, встречи, даты и т.д
                                 ___Классы___:
В свою очередь, класс (class) является шаблоном (каркасом), который можно использовать
для создания объектов. Класс определяет свойства и атрибуты объекта, а также действия, которые
он может выполнять. Например, рассмотрим класс, определяющий четырехколесный автомобиль 
с двигателем, который может перемещаться вперед и парковаться. На его основе можно
создать новый объект (новый автомобиль). 

                            -> СВОЙСТВА И МЕТОДЫ!
                                ___Свойства___:
  Объекты имеют свойства (property), также называемые атрибутами (attribute). Автомобиль
может быть красным, зеленым или быть покрашенным в горошек. Такие свойства автомобиля,
как цвет, размер или модель, являются внутренними характеристиками объекта. 
Обычно свойства класса задаются в виде переменных. Например, атрибут цвета может храниться в объекте
в виде переменной с отличительным именем, например $color. Тогда в объекте "автомобиль"
может содержаться переменная $color со значением красный ($color = красный).
Значения переменных, являющихся свойствами объектов, могут присваиваться по умолчанию 
или явно во время создания объектов. Они могут добавляться и изменяться и позже.
 При создании класса все его свойства следует объявить в начале соответствующего блока.
# class Car
#   {
#   var $color;      //В общем случае в РНР объявлять переменные необязательно, однако лучше этого не делать
#   var $tires;
#   var $gas;
#   Методы
#    }

	 Следующие выражения можно использовать в качестве значений по умолчанию:
#var $color = "черный"; 
#var $gas = 10;
#var $tires = 4; 
#var $doors = array("передняя часть", "задняя часть");   // простой массив
     Эти выражения нельзя использовать в качестве значений по умолчанию:
#var $color = "синий"." черный";
#var $gas = 10-3;
#var $tires = 2*2; 
 
                                    ___Методы___:
 Действия, которые могут выполнять объекты, иногда рассматриваются как его обязанности 
(responsibility). Например, объект "автомобиль" может перемещаться вперед и назад, 
останавливаться и парковаться. Каждое действие (обязанность), которое объект может выполнять,
реализуется в классе в виде метода (method). В языке PHP метод имеет тот же синтаксис, что и функция.
Разница заключается в том, что методы находятся внутри класса. Они не могут быть вызваны независимо 
от класса — интерпретатор РНР не позволит сделать это. Функции такого вида могут использоваться
только в контексте объекта. 
 В языке РНР определено несколько специальных методов, имена которых начинаются
с двух символов подчеркивания (__). Основные из них: construct, destruct и clone. 
                                    
									-> НАСЛЕДОВАНИЕ:
  Одним из подходов для разделения свойств и методов между классами является наследование (inheritance).
Наследование позволяет избежать дублирования информации. Например, есть белые и красные розы.
Сначала можно создать один класс Rose. Он может содержать общую информацию для роз,
такую как $plant = bush (вид растения — кустарник), $stem = thorns (стебел — с колючками),
$blooms = June (цветет в июне). Затем можно создать два подкласса для соответствующих видов роз.
Тогда класс Rose будет являться главным классом (master chss), win родительским классом (parent class). 
В свою очередь, классы redRose и whiteRose называются подклассами (subclass), 
или наследниками (child class), или потомками (child), как их ласково называет мой любимый профессор.
Классы-потомки наследуют все атрибуты и методы родительского класса. 
Однако они могут иметь и свои собственные свойства, например белый цвет ($color = белый) для класса
whiteRose и красный цвет ($color = красный) — для класса redRose.
Методы, содержащиеся в классе-наследнике, могут иметь те же имена, что и методы родительского класса. 
В этом случае метод класса-потомка имеет больший приоритет. 
При необходимости можно воспользоваться любым из этих методов. 

Если необходимо, чтобы класс наследовал свойства и методы другого класса, следует воспользоваться выражением:
#      class whiteRose extends Rose             //объект этого класса будет иметь доступ ко всем св-ам и методам классов whiteRose и Rose ->
#     {                                       // -> однако класс Rose не имеет досутпа к св-ам и методам класса-наследника 
#      Определение свойств класса
#     Определение методов класса
#      } 

                                ___Создание и использование класса___
    После выявления объектов и их свойств можно приступать к их созданию и истолкованию. 
Для создания и использования объекта нужно выполнить следующие действия:
   1. Использовать ключевое слово class. Ключевое слово class является основным при создании класса. 
С ним связывается блок инструкций со свойствами и методами класса.
   2. Вставить выражение class в те места, где необходимо использовать соответствующий объект. 
Класс можно разместить в самом сценарии. Однако чаще всего конструкцию class размещают в отдельном файле,
который включается в сценарий с помощью директивы include.
   3. Создать объект в сценарии. На основе описания класса можно создавать объекты, 
т.е. выполнять инстанцирование (instantiation).
   4. Использовать объект. После создания нового объекта можно приступать к егс использованию. 
При этом можно использовать любые методы класса, определенные в соответствующем блоке при его описании. 

                                          СОЗДАНИЕ КЛАССА:
синтаксис: 
   class имяКласса                                 // имя любое, кроме stdClass
      {
      Определение свойств класса
      Определение методов класса
      }
 */
                                      /* Переменная $THIS 
  Представляет собой ссылку на этот же класс, при этом ее нельзя использовать вне класса.
 Эта переменная обеспечивает доступ к переменным и методам класса внутри самого класса.
Синтаксис:       $this->имя_переменной
Например, для доступа к атрибуту $gas класса Саг следует воспользоваться выражением
#$this->gas 
Как видно в приведенных примерах, выражение "$this->имя_переменной" пспользуется
внутри класса точно так же, как и переменная "$имя_переменной" в сценарии. 
 */
 ?>
 ________________________________________________Начало III главы_____________________________________________
 <?php 
  echo "<p>";
 
  class Car                                           // создали класс 
 {
	 var $benz = 0;                                 // свойства или атрибут
	 function addBenz($amount)                     // методы 
	 {
		 $this->benz = $this->benz + $amount;
		 echo "<p> В бак залито $amount литров топливо (Car)";
	 }
 }
 $driver = new Car();                            // создали объект на основе класса Car 
 var_dump($driver);                             // вывод естественного вида объекта на экран
 $driver->addBenz(100);                        // выводим результат метода на экран 
 //include 
 ?>
<p>____________________________________________________144__________________________________________<p>

<?php
  
include("gl3_class.php");   // или require_once ("gl3_class.php") - включаем класс с готовой формой;

echo "<html><head><tittle><center> ФОРМА ДЛЯ ДОБАВЛЕНИЯ ТЕЛЕФОННОГО НОМЕРА <p></tittle> </head>";
echo "<body>";
$phone_form = new Form("process.php", "Отправить_данные");    // входные параметры класса
$phone_form->addField("first_name", "Имя");                  // входные параметры метода addField()
$phone_form->addField("last_name", "Фамилия");              
$phone_form->addField("phone", "Номер телефона");
echo "<hЗ>Пожалуйста, заполните поля данной формы:</h3></center>";
$phone_form->displayForm();         // вызов метода displayForm()
echo "</body></html>";
?>
 
 
 <p>_____________________________________________________181______________________________________________<p>

<?php 
              
# private - запрещает доступ к атрибутам и методам класса из-за пределов классов, сценариев или других классов

# protected - (защищенный) предоставляет доступ к защищенным свойствам и методам класса только для его классов-наследников,
# в остальных случаях доступ запрещен 

 class Car_secur
{
    private $gas = 0;    //атрибут становится скрытым, прямой доступ к нему невозможен
    private function addGas($amount)
    {
        $this->gas = $this->gas + $amount;
        echo "В бак залито $amount галлонов бензина (Car_secur)<br>";
    }
    function buyGas($amount)       // едиснственный возможный способ изменения атрибута $gas, не прямой доступ может изменить атрибут
    {
        $this->addGas($amount);
    }
}
$new_carrr = new Car_secur;
//$new_carrr->addGas(5); - вывожит либо ошибку, либо ничего не выводит
$new_carrr->buyGas(5);
 
echo "_____________________________________________________188______________________________________________<p>";

# Exception (исключение) -  применяется для обработки нежелательных событий
 class Car_exception
 {
  function testing()
  { 
try                                          // выполняется проверка условия, если true то делаем if
   {
    if ($this->gas < 0)
        {
        throw new Exception("Отрицательное количество бензина. ") ;    // создается новый объект класса Exception
        }
    }
    catch (Exception $e)     //перехват исключения и присваивается имя $e
        {
        echo $e->getMessage();            // вызывается метод getMessage() класса Exception (возвращает сообщение)
        echo "\n<br />\n";
        exit();
        }
  }       
 }

# __clone() - метод для копирования объектов, по дефолту копирует все атрибуты объекта.
# example (с переопределенным методом):
   class Car3
   {
    private $gas = 0;
    private $color = "Зеленый";
    function addGas($amount)
        {
        $this->gas = $this->gas + $amount;
        echo "в бак залито $amount галлонов бензина (Car3)<br>";
        }
    function __clone()
        {
        $this->gas = 0;
        }
    }
$fCar = new Car3;
$fCar->addGas(10);
$secondCar = clone $fCar; //происходит $secondCar = $fCar->__clone()

# unset($objName); - удаление объектов
# example:
unset($fCar);                          //удалили объект $fCar
unset($secondCar); 

# __destruct() - метод вызывается для удаления объекта, доп. делет оповещение при вызове данного удаленного объекта

class Bridge
{
    function destruct()
    {
    echo "Мост разрушен";
    }
}
$bigBridge = new Bridge; 
$bigBridge->destruct();
unset($bigBridge);
?>