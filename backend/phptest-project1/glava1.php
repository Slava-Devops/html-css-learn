<?php
header("Content-Type: text/html; charset=UTF-8");
?>

<html>
<head>
<title>
<p>Тестирование PHP, йоу!
</p>
</title>
</head>
<body>
<p> Это строка HTML
<?php
// echo "<p> Это строка PHP </p>";
# phpinfo();
?>

<?php
echo "<p> НА СЕГОДНЯ: </p>";                                              // оператор ввода вывода
?> 
</body>
</html>
 
<?php
/*$age = 25;                                                              // переменные
$price = 36.800;
$temperature = -10;
$name = "НЕО";
$color = "синий";
$color = "красный";
$name1 = "Артемий";
$name2 = "Анастасия";
$city = "a_a";
$my_favorite_name = $city;
echo $my_favorite_name;

$today = "<p> Понедельник </p>";
print_r ($today);                                                         // еще один оператор вывода

*/?>

<html>
<head> <title> Сценарий с использованием переменной </title> </head>
<body>
<?php 
$kurs_dollar = "$ = 58.9 сум ";                                          // переменные и данные
$kurs_evro = " Э = 63.1 сум";
echo "$kurs_dollar ", " <p> $kurs_evro </p>";
?>

 <p> Это раздел HTML </p>  

<?php
echo "Менэ син,а {$kurs_dollar} акча , успей купить малай!!!</p> ";       // переменная и смежный текст 
?>

</body>
</html>

<html>
<?php
$dollar = "58.9 рублей";
$evro = "63.1 рубля";
# $dollar =____;                                                            
//unset($evro, $dollar);                                                   // оператор удаления значения переменной
$kurs = "dollar";
echo "$kurs = ${$kurs}";                                                   // переменная в переменной 
$kurs = "evro";
echo "<p>$kurs = ${$kurs}</p>";
echo "<p>$dollar</p>", $evro;
?>
</html>
<p>-----------------------------------------------------------------------</p>

<html>
<?php

?>
</html>

<HTML>
<body>
<?php
#error_reporting (E_ALL $ ~E_NOTICE);                                 //изменение уровня проверки ошибок в сценарии, а именно показать все ошибки и уведомления
#error_reporting(0);                                                 //не отображать никакие сообщения об ошибках
define ("DOLLAR", "58.9 rub");                                      //присваиваем значение константе
echo DOLLAR, "<p></p>";

define ("CONSTANTA", "1000<p> </p>");                                        // операции с константами
$rus_rate = 1.7;
$eng_rate = 1.3;

print_r (CONSTANTA);                                                         // вывод константы 
echo CONSTANTA;
echo __FILE__, "<p> </p>";
$russia_win = $rus_rate * CONSTANTA;
$england_win = $eng_rate * CONSTANTA;

echo "Если Россия выйграет, то выручка = ", "$russia_win руб.", "<p></p>Если выйграет Англия, то выручка = ", "$england_win руб.<p></p>";
?>
</body>
</HTML>

<?php
$height_of_door = 50;
$height_of_house = 100;
if ($height_of_door > $height_of_house)                                         // оператор IF
{
trigger_error ("НЕ ВЕРНО", E_USER_ERROR);	                                    // триггер 
}
else
{
	echo "Выберите дальнейшие параметры please ___________________________<p> ";
}
?>

<?php
$d = 58.9;
$e = 63.1;
if ($d > $e)
{
	echo "<p>Америка натянула Европу! <br>";
//	eroor_log ("Америка натянула Европу!", 3, "/php/log/dol_evro");	
	exit();                                                                        // завершает все дальнейшие операции
}
?>

<?php
 $f_number = 1;                                                                           // целый тип данных - integer
 $s_number = 1.1;                                                                        // тип с плавающей точкой - floating point (float)
# $f_number = "ноль целых одна десятая";                                                // строковый тип - string
# $n_number = false, NULL (константа), 0, 0.0,  , "0" - это все FALSE, остальные TRUE; // булевый (логический) тип данных - boolean

                                                                                        //приведение типов
$s_number_new = (int)$s_number;                                                        // присваиваем переменной новую переменую с новым типом данных integer
$f_number_new = (float)$f_number;                                                     // присваиваем переменной новую переменую с новым типом данных
$nn_number_new = (string)$s_number;                                                  // присваиваем переменной новую переменую с новым типом данных                                                                                   
var_dump ($nn_number_new);                                                          // определяет и показывает тип переменной
echo "<p>";
?>


<?php 
$var1 = (1+3)*2+1;                                                                         // математические операции PHP
$var2 = 21%5;
$total = $var1 + $var2;

	if ($total > 10)
{
	echo "<p></p>$total значение больше чем 10 !" ;
}
if ($total < 10)
{
	echo "<br>$total значение меньше 10-ти !";
}

if ($total = 10)
{
	echo "<p></p>$total равно 10 !";
}
?>

<?php
$c = 0;
$c++;    
echo "<p>$c";                                                                          
// $c+=1;                                                                                    //инкрементирование (постфиксное)
   $c+=2;
// $c-=3;
// $c*=4;
// $c/=5;
echo "<p>$c"; 
$c--; //или $c-=1; и т.д.                                                                    //декрементирование (постфиксное)
echo "<p>$c</p> ";
?>

<?php
$var = sqrt(64);                                                                           //встроенные математические функции PHP (берем корень)
$var1 = 1156.161616;
$vartotal = sqrt($var1) + $var;
$v2 = ceil(27.1555);                                                 // функция округления действительного числа к ближайшему БОЛЬШЕМУ целому числу
$v3 = floor(26.1565);                                               // функция округления действительного числа к ближайшему МЕНЬШЕМУ целому числу
echo "<p>$vartotal";
echo "<p>$v2";
echo " <p>$v3</p> ";
printf ("<p>555.55555<p></p>");
echo number_format($var1, 3, ".", " "); //функция явно задает формат числа для вывода (число, кол-во десятичных знаков, "символ разделителя целого и дробного", "символ разделителя в целой части числа")
?>


<?php
$w = 8;                                                                     // heredoc- механизм , работа с длинными строками ("STRING" - произвольное слово)
$w_time = <<<STRING
<p>Время работы 
составляет $w часов ! <p>
STRING;
echo $w_time;
$n = "Война войной,  а обед по расписанию !!! </p>";                          // одинарные и двойные кавычки 
echo "<br> '$w' - интерпретируется значение переменной! <p>", 'Эти ковычки интерпретируют только имя переменной $w_time, т.е. выводит как есть! ';
echo "<p>\$w_time !";                                                         // backslash (\) - скрытие символов
echo '<p>seven o\'clock ! <p> ';
?>

<?php
$string1 = "ХАЙ,";
$string2 = "FIX!";
$string_all = $string1.$string2;                                                 //объединение текстовых строк 
echo $string_all;
echo "<p></p>";
$stringall = $string1." ".$string2;                                             //объединение текстовых строк c добавлением пробелов между ними 
echo $stringall, "<p>";
$stringall = "ХАААЙ,";
$stringall .= " ФИКС!";                                                        // .= в данном случае дописывает к строковому значению переменной текст 
echo $stringall, "<p>";
?>

 <?php
/*
 $stringg = "   Убираем пробелы   ! ";
$stringg = trim($stringg);                                                       // удаляет пробелы в начале и в конце строки 
//$stringg = ltrim($stringg);                                                   // удаляет пробелы только в начале строки 
//$stringg = rtrim($stringg);                                                  // удаляет пробелы только в концце строки
echo $stringg, "<p>";
*/
$str = "Podschet slov";
$numberOfWords = str_word_count($str);                                           //функция разбивающая строку на отдельные слова и добавляющая каждую по отдельности в массив
$word1 = str_word_count($str,1);
$word2 = str_word_count($str,2);
echo $numberOfWords, "<p>";
print_r ($word1);                                                                            // массив
echo "<p> </pre>";                                                                
var_dump ($word2);                                                                         // массив
echo "<p>";                                                     
?>

<?php
$n = strrev(" ! ovols eontarbo - emordnilap ");                                   // возвращает строку в обратном порядке
echo $n, "<p>";
$str = "YES YES YES";
$primer = strtolower($str);                                                       // преобразует все символы строки в нижний регистр
echo $primer, "<br>";
$prim = strtoupper("no no no");                                                   // преобразует все символы строки в верхний регистр
echo $prim, "<p>";
$p = "abcd abca";
$t = substr_replace($p, "x", 1, 7);                                               // заменяет в строке S($p) фрагмент из L(7 символов), начиная с позиции N(1), фрагментом R(x)
echo $t, "<p>";
$str2 = ucfirst("kazan 2017 !");                                                  // преобразует первый символ строки в верхний регистр
echo $str2, "<p>";
$str3 = ucwords("kaleykino forever !");                                           // преобразует первый символ каждого слова строки в верхний регистр
echo $str3, "<p>";
?>

<?php
$money = 30;
$product = "aлма";
$new = sprintf(" Бу %s тора %03.3f тиен.\n", $product, $money);                    // инструкция форматирования (%длина.точностьтип)
$new21 = ucfirst($product);                                                        // меняем регистр первой буквы слова на большую
$new2 = sprintf("%'.-20s стоимость %3.2f сум!", $new21, $money);                   // инструкция форматирования (%заполнитель-длина.точностьтип)
echo $new, "<br>";
echo $new2, "<p>";

$number1 = 12.30;
$number2 = 1;
$number3 = 77234.55;
printf("%5.2f <p>", $number1);                                                      // инструкция форматирования ("%" - символ инструкции форматирования, "5" - определяет ширину, кол-во знаков до точки, "2" кол-во знаков после точки, "f"(float) - тип строки)
printf("%5.2f <p>", $number2);
printf("%1.2f <p>", $number3); 

$old = 33.3;
$new = sprintf("$%.3f", $old);
echo $new, "<p>";
?>

<?php                                                                          // ПОДСЧЕТ ВОЗРАСТА ПО ДАТЕ ДНЯ РОЖДЕНИЯ
date_default_timezone_set('UTC');                                             //установка временной зоны по умолчанию. Доступно начиная с версии PHP 5.1
echo date("d F Y H:i:s "), "<p>";                                            //форматирование даты в формате "21 March 2017 13:04:56"
echo mktime(0,0,0,3,21,2017), "<p>";                                        //хранение значений в формате timestamp, команда time(), strtotime() дают такой же результат =>
echo strtotime("March 21 2017"), "<p>";                                    //=> результат подсчитывается в секундах, от 1 января 1970 00:00:00 GMT до указанного или по н.в.
$d = time();
echo $d, "<p>";

$today = time();                                                               // результат подсчитывается в секундах, от 1.01.1970 00:00:00 GMT до указанного или по н.в.
$birthday = mktime(7,15,0,6,8,1990);                                          // результат подсчитывается в секундах от 1.01.1970 до 07:15 часов 08.06.1990 г.
$years = $today-$birthday;
echo "Мой возраст в секундах = $years", "<p>";
$age = ((($years/60)/60)/24)/365;                                               // превращаем секунды в года
$age = number_format($age, 1, ".", " ");                                       // уменьшаем число до 0.1 десятичной
$age = floor($age);                                                           // округляем до меньшего целого значения                       
echo "Мне есть $age !", "<p>";
?>
                    <?PHP /* МАССИВЫ !!!	|     массив можно рассматривать как набор пар ключ-значение (key/value), т.е.												
                                            $arrayname['ключ1'] = значение1;
                                            $arrayname['ключ2'] = значение2;
                                            $arrayname['ключЗ'] = значениеЗ;   
						                    |     ключ (key) также называют индексом (index). 
*/?>


 <p>_______________________ 300 line - МАССИВЫ___________________________<p>
 
 <?php                                          
$foodPrices['onion'] = 0.50;                    // ОДНОМЕРНЫЙ МАССИВ (EXAMPLE)
$foodPrices['apple'] = 2.50;
$foodPrices['orange'] = 2.00;
$foodPrices['bacon'] = 3.50;
$foodPrices['potato'] = 1.00;
$foodPrices['ham'] = 5.00;
echo "<pre>";
print_r($foodPrices);
echo "<p> </pre>";
?>

<?PHP
$suzuki[color] = "Black";
$suzuki[type] = "Jeep";
$suzuki[price] = "1 500 000 RUB";
echo "$suzuki[price]", "<p>";

$streets[] = "ул.Токарликова ";                                                   // создается массив с автоматической нумерацией индексов, начиная с 0-ля
$streets[] = "ул. Молодежная";
$streets[] = "ул. Специалистов";
echo "$streets[0]", "<p>";

$streets = array("ул.Токарликова", "ул. Молодежная", "ул. Специалистов");           // сокращенная запись создания того же массива 
$streets = array(11 => "ул.Токарликова ", "ул. Молодежная ", "ул. Специалистов");  // отсчет в массиве начнется с 11, а не с нуля
echo $streets[11],$streets[12],$streets[13], "<p>";

$city = array ("Kn" => "Kazan",                                                    //присваиваем имя массива и его значение
               "Alm" => "Almet",
			   "Ch" => "Chelny");
echo $city[Kn], " <p> "; 

$years = range(2000, 2017);
$alfavit = range("z", "a");                                                        //автоматически создаем массивы в некотором диапазоне 
echo $years[10], "!<p>";
echo $alfavit[1], "<p><pre>";                                                    // HTML тег "pre" - делает упорядоченную расстановку 
print_r($years);                                                                // выводится наиболее общая информация (только индекс и значение)
echo "</pre><p><pre>";                                                          
var_dump($city);                                                              // выводится более полная информация 
echo "</pre><pre>";  
print_r($alfavit);   
echo "</pre><pre>"; 

$suzuki[model] = "Grand Vitara";                                           // добавление значения в массив
print_r($suzuki);
echo "</pre>";
$suzukicopy = $suzuki;                                                  // копирование массива 
echo "<pre>";
var_dump($suzukicopy);
echo "</pre>";

$suzukicopy[model] = "";                                                                               // опусташаем элемент массива
unset($suzukicopy[model]);                                                                            // удаляет элемент массива
echo "<pre>";
var_dump($suzukicopy);
echo "</pre>";
unset($suzukicopy);                                                                                // полностью удаляем массив
echo "Удалил массив \$suzukicopy! <p> ", "Результат вывода команды: 'var_dump(\$suzukicopy)' => ";
var_dump($suzukicopy);
echo "<p><pre>";

sort($city);                                              // СОРТИРОВКА массива - сначала числа, после значения по алфавиту, индексы присваиваются по новой 
                                                         // если индексы в виде текстовых строк, то команда преобразует их в числа
print_r($city);
echo "<p><pre>";

asort($suzuki);                                                // сортирует значения по возрастанию алфавита, при этом не изменяя индексы массива
print_r($suzuki);
rsort($city);                                                // сортирует значения элементов массива по убыванию, присваивая при этом новые числовые индексы 
arsort($city);                                              // сортирует значения элементов массива по убыванию, не изменяя при этом индексы 
ksort($city);                                              // cортирует индексы элементов массива по возрастанию 
krsort($city);                                            // cортирует индексы элементов массива по убыванию 
/*natsort($sity);                    Сортирует смешанные значения (текстовые и числовые) элементов массива и устанавливает "естественный" порядок. 
                                     Например, массив со значениями dayl , day5, dayll , day2 будет отсортирован следующим образом: 
									 dayl, day2, days, dayll. В то время как результатом выполнения функции
                                     sort () будет: dayl , dayll , day2, day5                                   								  */
$PRICEsuzuki = $suzuki['price'];                                                                         // присваивание переменной элемента массива 
echo "Стомимость suzuki grand vitara = ", $PRICEsuzuki; 

@$NO_suzuki = $suzuki[no_element];                                                                       // @ - для предотвращения сообщения об ошибке 

echo "<p>", $suzuki['price'];
echo "<p>", "My {$suzuki['type']} is a {$suzuki['color']} color!", "<p>";                                // использование ECHO в массивах

$VAR = array("мокасины", "красные", "Пацанские "); 
print_r($VAR);
list($first, $second, $third) = $VAR;                             // будут присвоены значения первых трех ... элементов массива $VAR    
/* это эквивалентно выполнению операторов:
$first  =  $VAR[0];
$second =  $VAR[1];
$third  =  $VAR[2];    
*/                                                              
echo $third, $second, " ", $first, ", йоу!<p>";

$sss['MARKA'] = "Марка авто";                                     // 1. создаем массив 
$k = key($sss);                                                  // 2. используем KEY - для получения индекса элемента массива
echo "$k =>>> {$suzuki['model']} <p>";

$com = array    ('1' => "Первый",                                  //присваиваем имя массива и его значение
                 '2' => "Второй",
			     '3' => "Третий",
				 '4' => "Четвертый",
				 '5' => "Пятый");
$b = current($com);                                            // возвращает текущее значение элемента массива, не перемещая указатель =>
echo "$b<br>";                                                // => поскольку указатель ранее не перемещался, по умолчанию он установлен на первый элемент массива
$b = next($com);                                             // перемещает указатель вперед на один элемент
$b = next($com);                                             
echo "$b<br>";
$b = prev($com);                                           // перемещает указатель назад на один элемент
echo "$b<br>";
$b = end($com);                                          // перемещает указатель в конец массива
echo "$b<br>";
$b = reset($com);                                      // перемещает указатель в начало массива =>
echo "$b<br><p>_____________________________<p>";     // => если же положение указателя изменялось в предыдущих строках кода или нет уверенности, что отсчет начнется с первого элемента, то используем reset


$tat_population = array ("Kz" => 1150000,
                         "Ch" => 700000,
                         "Alm" => 350000);
ksort($tat_population);                                    // cортируем индексы элементов массива по от меньшего к большому 
print_r($tat_population);                                 // показываем массив

     foreach($tat_population as $state => $population)        // осуществляет поэлементный проход по массиву и позволяет выполнить набор инструкций со значениями и индексами
{
$population = number_format($population);                // форматирование числа для вывода (по дефолту)
echo "$state : $population.<br><p>";
}
/*    foreach{$имя_массива as $ключ => $значение) 
     {                                         
      набор операторов;
	 }                 
$ключ - имя переменной, которой будут присваиваться значения индексов элементов массива,  этот параметр является необязательным, 
т.е. без его использования сохранится только значение элемента массива в переменной $значение. 
$значение - имя переменной, которой будут присваиваться значения элементов массива
*/
     foreach($tat_population as $population)    //  в этом случае мы будем иметь доступ только к значениям (численности населения) массива, но не к индексам
{                                           
$population = number_format($population);              
echo " $population <br><p>"; 
}
// при использовании оператора foreach указатель автоматически перемещается в начало, т.е. нет необходимости использовать функцию reset()

$n = count($tat_population);                                                           // определение размера массива                     
$t = sizeof($com);                                                                     // определение размера массива 
echo "Размер массива \$tat_population : $n", "<p>","Размер массива \$com : ", $t, "<p>";

                                                            // преобразование массивов в текстовые строки и наоборот
$age = "08:06:1990";
$arrayname = explode(":",$age);                             // преобразуем из строки в массив -> $arrayname = explode("разделяющий символ", $строки); 
echo "___________________________<p>";
echo $age, "<p>";
print_r($arrayname);
                                                            // обе команды не изменяет значения входных аргументов, а только считывает их
$arr = array("08", "06", "1990");
$restring = implode(" / ", $arr);                           // преобразуем из массива в строку -> $restring = implode(" разделяющий символ", $массива); 
echo "___________________________<p>";
print_r ($arr);
echo $restring, "<p>";

$massiv = array("yellow" => "тюльпаны", "red" => "розы");
extract($massiv);                                             //функция EXTRACT позволяет получать значения элементов массива и присваивать их переменным, именами которых являются соответствующие индексы
echo "Очень красивые бываюют голландские $red!\n";
echo "Любимыми желтыми цветами жены являются $yellow.<p>"; 

$aaa = "белый";
$bbb = "черный";
$ccc = "серебристый";
$ddd = "фиолетовый";
$arrayIN = array("aaa", "bbb");
$arrayOUT = compact("ccc", "ddd",  $arrayIN);                 //функция COMPACT предназначена для добавления набора переменных в массив
print_r ($arrayOUT);

$testarray = array("красный", "зеленый", "синий", "розовый");
$subArray = array_slice($testarray , 1, 2);                           //РАЗБИЕНИЕ МАССИВА, имеет вид: "$subArray = array_slice($массив, nl, п2);" n1 - позиция элемента, с которого начинается разбиение исходного массива, n2 - кол-во элементов нового массива 
print_r ($subArray); 

$a123 = array("feature1" => "деловой", "feature2" => "ровный");
$b123 = array("feature1" => "четкий", "feature3" => "понтовый");
$bigArray = array_merge($a123, $b123);                            //СЛИЯНИЕ МАССИВА, если индексы для некоторых элементов совпадают, последний из них заменит первоначальный
print_r($bigArray);
$bigArray = array_merge_recursive ($a123, $b123);               //СЛИЯНИЕ МАССИВА, если индексы для некоторых элементов совпадают, то создается многомерный массив, вместо перезаписывания значений с одинаковыми индексами
print_r($bigArray);
echo "<p>_______________________ 484 line ___________________________<p>";
                                                              //СРАВНЕНИЕ МАССИВОВ 
$ar1 = array("a" => "яблоко", "b" => "апельсин", "c" => "банан");
$ar2 = array("слива", "апельсин", "банан");
$diffArray = array_diff($ar1, $ar2);                       //array_diff(%массив1, $массив2, ...) - массив $diffArray будет содержать элементы из $arrayl, значения которых отсутствуют в $аггау2. При этом в результирующем массиве ключи сохранят свои значения. Порядок следования аргументов очень важен.
print_r ($diffArray);

$result = array_diff_assoc($ar2, $ar1);                  //находит элементы, отличающиеся ключом и своим значением, не или! Порядок следования аргументов также очень важен.
print_r($result);

$nextar = array_intersect($ar1, $ar2);                //находит одинаковые значения элементов в двух и более массивах, в $nextar добавляется новый индекс от первого массива, если значения одинаковы  
print_r($nextar);

$nextarr = array_intersect_assoc($ar1, $ar2);      //находит одинаковые значения элементов, но учитывает равенство как ключа, так и значения элемента
print_r($nextarr); 

echo "<p>_______________________ 500 line ___________________________<p>";

$arrayAdd = array(3, 4, "5-ть");
$sum = array_sum($arrayAdd);                       //СУММИРОВАНИЕ ЗНАЧЕНИЙ МАССИВА, текстовые строки автоматически преобразуются в 0, если в ней нет цифр
echo $sum, "<p>"; 

$name = array("Валерик", "Андрей", "Сергей", "Александр", "Олег", "Олег"); 
$names = array_unique($name);                       //УДАЛЕНИЕ ПОВТОРЯЮЩИХСЯ ЭЛЕМЕНТОВ МАССИВА
print_r ($names);

$r['Первый'] = Один;
$r['Второй' ] = Два;
print_r($r);
$rokirovka = array_flip($r);                    //перестановка местами ключей и значений массива 
print_r($rokirovka);

echo "<p>_______________________ 516 line ___________________________<p>";

$foodPrices['vegetable']['onion'] = 0.50;          // МНОГОМЕРНЫЙ МАССИВ (EXAMPLE)
$foodPrices ['vegetable']['potato'] = 1.00;
$foodPrices['fruit']['apple'] = 2.50;
$foodPrices['fruit']['orange'] = 2.00;
$foodPrices['meat']['bacon'] = 3.50;
$foodPrices['meat']['ham'] = 5.00; 
print_r($foodPrices);
echo "<pre>";
echo "</pre>_____________________________________________\n";

$transport ['car'][] = "Форд";
$transport ['car'][] = "SUZUKI";
print_r($transport);

$football = array (                                                                 //еще один способ создания многомерного массива 
            "england" => array ("com1" => "arsenal", "com2" => "manchester city"),
			"germany" => array ("command1" => "bavaria", "command2" => "berlin"));
print_r($football);	
echo "<p>";
var_dump($football);		
echo "<p>";
$winner = $football['england']['com2'];                             //доступ к элементам осуществляется на прямую и вноситя в переменную
echo $football['england']['com1'], "<p>";                          // вывод конкретного значения многомерного массива
echo "{$football['germany']['command1']} пьет пиво!!!", "<p>";    // вывод значения массива в строковом формате
echo $resString = implode(":" , $football['germany']), "<p>";           // преобразование массива в строку с разделением ":"

foreach ($football as $category )                               //проход по внешнему массиву 
{
   foreach ($category as $country =>$command)                 //проход по внутреннему массиву 
    {
    //$f =sprintf("%01.2f",$command);
    echo "$country: $command \n";
    }
}
 echo $_SERVER['PHP_SELF'], "<p>";                                //информации об имени текщущего запущенного сценария (имя файла)

foreach($_SERVER as $key => $value)
{
 echo " Ключ = $key, Значение = $value\n ";                       //cодержит информацию об используемом сервере
 }
?>